<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fantaixi.github.io</id>
    <title>饭太稀</title>
    <updated>2020-05-04T06:55:19.008Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fantaixi.github.io"/>
    <link rel="self" href="https://fantaixi.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://fantaixi.github.io/images/avatar.png</logo>
    <icon>https://fantaixi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 饭太稀</rights>
    <entry>
        <title type="html"><![CDATA[07 Java 数组]]></title>
        <id>https://fantaixi.github.io/post/07-java-shu-zu/</id>
        <link href="https://fantaixi.github.io/post/07-java-shu-zu/">
        </link>
        <updated>2020-05-03T06:11:20.000Z</updated>
        <content type="html"><![CDATA[<p>一、数组的理解：数组(Array)，是多个相同类型数据一定顺序排列的集合，并使用一个名字命名，<br>
并通过编号的方式对这些数据进行统一管理。</p>
<p>二、数组相关的概念：</p>
<blockquote>
<p>数组名<br>
元素<br>
角标、下标、索引<br>
数组的长度：元素的个数</p>
</blockquote>
<p>三、数组的特点：<br>
1数组是序排列的<br>
2数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型<br>
3创建数组对象会在内存中开辟一整块连续的空间<br>
4数组的长度一旦确定，就不能修改。</p>
<p>四、数组的分类：<br>
① 照维数：一维数组、二维数组、。。。<br>
② 照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组</p>
<p>五、一维数组<br>
1、声明与初始化<br>
正确的方式：<br>
int num;//声明<br>
num = 10;//初始化<br>
int id = 1001;//声明 + 初始化</p>
<pre><code>	int[] ids;//声明
	//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行
	ids = new int[]{1001,1002,1003,1004};
	//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行
	String[] names = new String[5];

int[] arr4 = {1,2,3,4,5};//类型推断
</code></pre>
<p>错误的方式：<br>
//		int[] arr1 = new int[];<br>
//		int[5] arr2 = new int[5];<br>
//		int[] arr3 = new int[3]{1,2,3};</p>
<p>2、一维数组元素的引用：通过角标的方式调用。<br>
//数组的角标（或索引从0开始的，到数组的长度-1结束。<br>
names[0] = &quot;王铭&quot;;<br>
names[1] = &quot;王赫&quot;;<br>
names[2] = &quot;张学良&quot;;//charAt(2)</p>
<p>3、数组的属性：length<br>
System.out.println(names.length);//5<br>
System.out.println(ids.length);</p>
<p>说明：<br>
数组一旦初始化，其长度就是确定的。arr.length<br>
数组长度一旦确定，就不可修改。</p>
<p>4、一维数组的遍历<br>
for(int i = 0;i &lt; names.length;i++){<br>
System.out.println(names[i]);<br>
}</p>
<p>5.一维数组元素的默认初始化值</p>
<blockquote>
<p>数组元素是整型：0<br>
数组元素是浮点型：0.0<br>
数组元素是char型：0或'\u0000'，而非'0'<br>
数组元素是boolean型：false<br>
数组元素是引用数据类型：null</p>
</blockquote>
<p>六、二维数组<br>
1、如何理解二维数组？<br>
数组属于引用数据类型<br>
数组的元素也可以是引用数据类型<br>
一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</p>
<p>2、二维数组的声明与初始化<br>
正确的方式：<br>
int[] arr = new int[]{1,2,3};//一维数组<br>
//静态初始化<br>
int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};<br>
//动态初始化1<br>
String[][] arr2 = new String[3][2];<br>
//动态初始化2<br>
String[][] arr3 = new String[3][];<br>
//也是正确的写法：<br>
int[] arr4[] = new int[][]{{1,2,3},{4,5,9,10},{6,7,8}};<br>
int[] arr5[] = {{1,2,3},{4,5},{6,7,8}};//类型推断<br>
错误的方式：<br>
//		String[][] arr4 = new String[][4];<br>
//		String[4][3] arr5 = new String[][];<br>
//		int[][] arr6 = new int[4][3]{{1,2,3},{4,5},{6,7,8}};<br>
3、如何调用二维数组元素:<br>
System.out.println(arr1[0][1]);//2<br>
System.out.println(arr2[1][1]);//null<br>
arr3[1] = new String[4];<br>
System.out.println(arr3[1][0]);<br>
System.out.println(arr3[0]);//<br>
4、二维数组的属性：<br>
System.out.println(arr4.length);//3<br>
System.out.println(arr4[0].length);//3<br>
System.out.println(arr4[1].length);//4<br>
5、遍历二维数组元素<br>
for(int i = 0;i &lt; arr4.length;i++){	<br>
for(int j = 0;j &lt; arr4[i].length;j++){<br>
System.out.print(arr4[i][j] + &quot;  &quot;);<br>
}<br>
System.out.println();<br>
}</p>
<p>6、二维数组元素的默认初始化值</p>
<ul>
<li>规定：二维数组分为外层数组的元素，内层数组的元素</li>
<li>
<pre><code> int[][] arr = new int[4][3];
</code></pre>
</li>
<li>
<pre><code> 外层元素：arr[0],arr[1]等
</code></pre>
</li>
<li>
<pre><code> 内层元素：arr[0][0],arr[1][2]等
</code></pre>
</li>
<li></li>
<li>数组元素的默认初始化值</li>
<li>针对于初始化方式一：比如：int[][] arr = new int[4][3];</li>
<li>
<pre><code> 外层元素的初始化值为：地址值
</code></pre>
</li>
<li>
<pre><code> 内层元素的初始化值为：与一维数组初始化情况相同
</code></pre>
</li>
<li></li>
<li>针对于初始化方式二：比如：int[][] arr = new int[4][];</li>
<li>
<pre><code> 外层元素的初始化值为：null
</code></pre>
</li>
<li>
<pre><code> 内层元素的初始化值为：不能调用，否则报错。
</code></pre>
</li>
</ul>
<p>七、Arrays工具类的使用<br>
1.理解：<br>
① 定义在java.util包下。<br>
② Arrays:提供了很多操作数组的方法。</p>
<p>2.使用（常用）：<br>
//1.boolean equals(int[] a,int[] b):判断两个数组是否相等。<br>
int[] arr1 = new int[]{1,2,3,4};<br>
int[] arr2 = new int[]{1,3,2,4};<br>
boolean isEquals = Arrays.equals(arr1, arr2);<br>
System.out.println(isEquals);</p>
<pre><code>	//2.String toString(int[] a):输出数组信息。
	System.out.println(Arrays.toString(arr1));
			
	//3.void fill(int[] a,int val):将指定值填充到数组之中。
	Arrays.fill(arr1,10);
	System.out.println(Arrays.toString(arr1));
	
	//4.void sort(int[] a):对数组进行排序。
	Arrays.sort(arr2);
	System.out.println(Arrays.toString(arr2));
	
	//5.int binarySearch(int[] a,int key)
	int[] arr3 = new int[]{-98,-34,2,34,54,66,79,105,210,333};
	int index = Arrays.binarySearch(arr3, 210);
	if(index &gt;= 0){
		System.out.println(index);
	}else{
		System.out.println(&quot;未找到&quot;);
	}
</code></pre>
<p>八、数组常见异常<br>
1.数组角标越界异常：ArrayIndexOutOfBoundsException<br>
int[] arr = new int[]{1,2,3,4,5};		<br>
//		for(int i = 0;i &lt;= arr.length;i++){<br>
//			System.out.println(arr[i]);<br>
//		}		<br>
//		System.out.println(arr[-2]);</p>
<p>2.空指针异常：NullPointerException<br>
//情况一：<br>
//		int[] arr1 = new int[]{1,2,3};<br>
//		arr1 = null;<br>
//		System.out.println(arr1[0]);</p>
<p>//情况二：<br>
//		int[][] arr2 = new int[4][];<br>
//		System.out.println(arr2[0][0]);</p>
<p>//情况三：<br>
String[] arr3 = new String[]{&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;};<br>
arr3[0] = null;<br>
System.out.println(arr3[0].toString());</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[06 Java流程控制]]></title>
        <id>https://fantaixi.github.io/post/06-java-liu-cheng-kong-zhi/</id>
        <link href="https://fantaixi.github.io/post/06-java-liu-cheng-kong-zhi/">
        </link>
        <updated>2020-05-02T08:16:37.000Z</updated>
        <content type="html"><![CDATA[<p>一、顺序结构：程序从上到下执行。<br>
分支结构：<br>
if-else if - else<br>
switch-case</p>
<p>1.if-else条件判断结构<br>
1.1.<br>
结构一：<br>
if(条件表达式){<br>
执行表达式<br>
}</p>
<p>结构二：二选一<br>
if(条件表达式){<br>
执行表达式1<br>
}else{<br>
执行表达式2<br>
}</p>
<p>结构三：n选一<br>
if(条件表达式){<br>
执行表达式1<br>
}else if(条件表达式){<br>
执行表达式2<br>
}else if(条件表达式){<br>
执行表达式3<br>
}<br>
...<br>
else{<br>
执行表达式n<br>
}</p>
<p>1.2.说明：</p>
<ol>
<li>else 结构是可选的。</li>
<li>针对于条件表达式：
<blockquote>
<p>如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。<br>
如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。<br>
如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。（比如异常处理）</p>
</blockquote>
</li>
<li>if-else结构是可以相互嵌套的。</li>
<li>如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</li>
</ol>
<p>2.switch-case选择结构<br>
switch(表达式){<br>
case 常量1:<br>
执行语句1;<br>
//break;<br>
case 常量2:<br>
执行语句2;<br>
//break;<br>
...<br>
default:<br>
执行语句n;<br>
//break;<br>
}<br>
2.说明：<br>
① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。<br>
当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。<br>
② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构<br>
③ switch结构中的表达式，只能是如下的6种数据类型之一：<br>
byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)<br>
④ case 之后只能声明常量。不能声明范围。<br>
⑤ break关键字是可选的。<br>
⑥ default:相当于if-else结构中的else.<br>
default结构是可选的，而且位置是灵活的。<br>
3.如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。<br>
4.break在switch-case中是可选的</p>
<p>二、循环结构：<br>
for<br>
while<br>
do-while</p>
<p>1.循环结构的四要素<br>
① 初始化条件<br>
② 循环条件  ---&gt;是boolean类型<br>
③ 循环体<br>
④ 迭代条件<br>
说明：通常情况下，循环结束都是因为②中循环条件返回false了。</p>
<p>2.三种循环结构：<br>
2.1 for循环结构<br>
for(①;②;④){<br>
③<br>
}<br>
执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②<br>
2.2 while循环结构<br>
①<br>
while(②){<br>
③;<br>
④;<br>
}<br>
执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②<br>
说明：<br>
写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</p>
<p>for和while循环总结：</p>
<ol>
<li>开发中，基本上我们都会从for、while中进行选择，实现循环结构。</li>
<li>for循环和while循环是可以相互转换的！<br>
区别：for循环和while循环的初始化条件部分的作用范围不同。</li>
<li>我们写程序，要避免出现死循环。<br>
2.3 do-while循环结构<br>
①<br>
do{<br>
③;<br>
④;<br>
}while(②);<br>
执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②</li>
</ol>
<p>说明：<br>
1.do-while循环至少会执行一次循环体！<br>
2.开发中，使用for和while更多一些。较少使用do-while</p>
<p>3.“无限循环”结构: while(true) 或 for(;😉<br>
总结：如何结束一个循环结构？<br>
方式一：当循环条件是false时<br>
方式二：在循环体中，执行break</p>
<p>4.嵌套循环<br>
1.嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环<br>
内层循环：循环结构A<br>
外层循环：循环结构B<br>
2.说明：<br>
① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次<br>
② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次<br>
③ 外层循环控制行数，内层循环控制列数<br>
【典型练习】<br>
//练习一：<br>
/*<br>
******<br>
******<br>
******<br>
******<br>
<em>/<br>
for(int j = 1;j &lt;= 4;j++ ){<br>
for(int i = 1;i &lt;= 6;i++){<br>
System.out.print('</em>');<br>
}<br>
System.out.println();<br>
}<br>
//练习二：<br>
/*			i(行号)		j(*的个数)<br>
*			1			1<br>
**			2			2<br>
***			3			3<br>
****		4			4<br>
*****		5			5<br>
*/</p>
<pre><code>	for(int i = 1;i &lt;= 5;i++){//控制行数
		for(int j = 1;j &lt;= i;j++){//控制列数
			System.out.print(&quot;*&quot;);
		
		}
		System.out.println();
	}
	//练习三：九九乘法表
	//练习四：100以内的质数
</code></pre>
<p>补充:衡量一个功能代码的优劣：<br>
1.正确性<br>
2.可读性<br>
3.健壮性<br>
4.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</p>
<p>如何理解流程控制的练习：<br>
流程控制结构的使用 + 算法逻辑</p>
<p>小结：break和continue关键字的使用<br>
使用范围		循环中使用的作用(不同点)	  相同点</p>
<p>break:	 switch-case			<br>
循环结构中		   结束当前循环		关键字后面不能声明执行语句</p>
<p>continue:	循环结构中	 结束当次循环		关键字后面不能声明执行语句</p>
<p>补充：带标签的break和continue的使用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[05 Java运算符]]></title>
        <id>https://fantaixi.github.io/post/05-java-yun-suan-fu/</id>
        <link href="https://fantaixi.github.io/post/05-java-yun-suan-fu/">
        </link>
        <updated>2020-05-01T08:26:47.000Z</updated>
        <content type="html"><![CDATA[<p>一、算术运算符： + -  * / % (前)++ (后)++ (前)-- (后)--<br>
【典型代码】<br>
//除号：/<br>
int num1 = 12;<br>
int num2 = 5;<br>
int result1 = num1 / num2;<br>
System.out.println(result1);//2<br>
// %:取余运算<br>
//结果的符号与被模数的符号相同<br>
//开发中，经常使用%来判断能否被除尽的情况。<br>
int m1 = 12;<br>
int n1 = 5;<br>
System.out.println(&quot;m1 % n1 = &quot; + m1 % n1);</p>
<pre><code>	int m2 = -12;
	int n2 = 5;
	System.out.println(&quot;m2 % n2 = &quot; + m2 % n2);

	int m3 = 12;
	int n3 = -5;
	System.out.println(&quot;m3 % n3 = &quot; + m3 % n3);

	int m4 = -12;
	int n4 = -5;
	System.out.println(&quot;m4 % n4 = &quot; + m4 % n4);
	//(前)++ :先自增1，后运算
	//(后)++ :先运算，后自增1
	int a1 = 10;
	int b1 = ++a1;
	System.out.println(&quot;a1 = &quot; + a1 + &quot;,b1 = &quot; + b1);
	
	int a2 = 10;
	int b2 = a2++;
	System.out.println(&quot;a2 = &quot; + a2 + &quot;,b2 = &quot; + b2);
	
	int a3 = 10;
	++a3;//a3++;
	int b3 = a3;
	//(前)-- :先自减1，后运算
	//(后)-- :先运算，后自减1
	
	int a4 = 10;
	int b4 = a4--;//int b4 = --a4;
	System.out.println(&quot;a4 = &quot; + a4 + &quot;,b4 = &quot; + b4);
</code></pre>
<p>【特别说明的】<br>
1.//(前)++ :先自增1，后运算<br>
//(后)++ :先运算，后自增1<br>
2.//(前)-- :先自减1，后运算<br>
//(后)-- :先运算，后自减1<br>
3.连接符：+：只能使用在String与其他数据类型变量之间使用。</p>
<p>二、赋值运算符：=  +=  -=  <em>=  /=  %=<br>
【典型代码】<br>
int i2,j2;<br>
//连续赋值<br>
i2 = j2 = 10;<br>
//</em>**************<br>
int i3 = 10,j3 = 20;<br>
int num1 = 10;<br>
num1 += 2;//num1 = num1 + 2;<br>
System.out.println(num1);//12</p>
<pre><code>	int num2 = 12;
	num2 %= 5;//num2 = num2 % 5;
	System.out.println(num2);

	short s1 = 10;
	//s1 = s1 + 2;//编译失败
	s1 += 2;//结论：不会改变变量本身的数据类型
	System.out.println(s1);
</code></pre>
<p>【特别说明】<br>
1.运算的结果不会改变变量本身的数据类型<br>
2.<br>
//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)<br>
//方式一：num = num + 2;<br>
//方式二：num += 2; (推荐)</p>
<pre><code>	//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)
	//方式一：num = num + 1;
	//方式二：num += 1; 
	//方式三：num++; (推荐)
</code></pre>
<p>三、比较运算符（关系运算符）: == != &gt;  &lt;  &gt;=  &lt;=  instanceof<br>
【典型代码】<br>
int i = 10;<br>
int j = 20;</p>
<pre><code>	System.out.println(i == j);//false
	System.out.println(i = j);//20

	boolean b1 = true;
	boolean b2 = false;
	System.out.println(b2 == b1);//false
	System.out.println(b2 = b1);//true
</code></pre>
<p>【特别说明】<br>
1.比较运算符的结果是boolean类型<br>
2.&gt;  &lt;  &gt;=  &lt;= :只能使用在数值类型的数据之间。<br>
3. == 和 !=: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。<br>
Account acct1 = new Account(1000);<br>
Account acct2 = new Account(1000);<br>
boolean b1 = (acct1 == acct2);//比较两个Account是否是同一个账户。<br>
boolean b2 = (acct1 != acct2);//</p>
<p>四、逻辑运算符：&amp; &amp;&amp;  |  || !  ^<br>
【典型代码】<br>
//区分&amp; 与 &amp;&amp;<br>
//相同点1：&amp; 与  &amp;&amp; 的运算结果相同<br>
//相同点2：当符号左边是true时，二者都会执行符号右边的运算<br>
//不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。<br>
//开发中，推荐使用&amp;&amp;<br>
boolean b1 = true;<br>
b1 = false;<br>
int num1 = 10;<br>
if(b1 &amp; (num1++ &gt; 0)){<br>
System.out.println(&quot;我现在在北京&quot;);<br>
}else{<br>
System.out.println(&quot;我现在在南京&quot;);<br>
}</p>
<pre><code>	System.out.println(&quot;num1 = &quot; + num1);
	
	boolean b2 = true;
	b2 = false;
	int num2 = 10;
	if(b2 &amp;&amp; (num2++ &gt; 0)){
		System.out.println(&quot;我现在在北京&quot;);
	}else{
		System.out.println(&quot;我现在在南京&quot;);
	}

	System.out.println(&quot;num2 = &quot; + num2);

	// 区分：| 与 || 
	//相同点1：| 与  || 的运算结果相同
	//相同点2：当符号左边是false时，二者都会执行符号右边的运算
	//不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算
	//开发中，推荐使用||
	boolean b3 = false;
	b3 = true;
	int num3 = 10;
	if(b3 | (num3++ &gt; 0)){
		System.out.println(&quot;我现在在北京&quot;);
	}else{
		System.out.println(&quot;我现在在南京&quot;);
	}
	System.out.println(&quot;num3 = &quot; + num3);


	boolean b4 = false;
	b4 = true;
	int num4 = 10;
	if(b4 || (num4++ &gt; 0)){
		System.out.println(&quot;我现在在北京&quot;);
	}else{
		System.out.println(&quot;我现在在南京&quot;);
	}
	System.out.println(&quot;num4 = &quot; + num4);
</code></pre>
<p>【特别说明】<br>
逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型</p>
<p>五、位运算符：&lt;&lt;  &gt;&gt; &gt;&gt;&gt; &amp;  |  ^  ~<br>
【典型代码】<br>
int i = 21;<br>
i = -21;<br>
System.out.println(&quot;i &lt;&lt; 2 :&quot; + (i &lt;&lt; 2));   // i &lt;&lt; 2 :-84<br>
System.out.println(&quot;i &lt;&lt; 3 :&quot; + (i &lt;&lt; 3));   // i &lt;&lt; 3 :-168<br>
System.out.println(&quot;i &lt;&lt; 27 :&quot; + (i &lt;&lt; 27));   //  i &lt;&lt; 27 :1476395008</p>
<pre><code>	int m = 12;
	int n = 5;
	System.out.println(&quot;m &amp; n :&quot; + (m &amp; n));   //  m &amp; n :4
	System.out.println(&quot;m | n :&quot; + (m | n));    //  m | n :13
	System.out.println(&quot;m ^ n :&quot; + (m ^ n));   //  m ^ n :9
</code></pre>
<p>【面试题】 你能否写出最高效的2 * 8的实现方式？<br>
答案：2 &lt;&lt; 3  或  8 &lt;&lt; 1<br>
【特别说明的】</p>
<ol>
<li>位运算符操作的都是整型的数据</li>
<li>&lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2
<blockquote>
<blockquote>
<p>:在一定范围内，每向右移1位，相当于 / 2</p>
</blockquote>
</blockquote>
</li>
</ol>
<p>典型题目：<br>
1.交换两个变量的值。（int a=1,b=2）<br>
a =  a ^ b;<br>
b =  a ^ b;//此时的a已经不是原来的a了，此时右边的表达式就等价于：( a ^ b ) ^ b ，结果是a，并把它赋予变量b；<br>
a =  a ^ b;//此时的a与b都不是原来的a与b了，此时右边的表达式就等价于：a ^ ( a ^ b ) ，结果是b，并把它赋予变量a；</p>
<p>2.实现60的二进制到十六进制的转换<br>
public static void BitCalc() {<br>
//获取60的二进制<br>
System.out.println(Integer.toBinaryString(60));<br>
int num =60;<br>
int n1 = num &amp; 15;<br>
int temp = 60 &gt;&gt; 4;<br>
int n2 = temp &amp; 15;<br>
System.out.print(n2);	<br>
System.out.println((char)(n1-10+'A'));<br>
//三元运算<br>
int x =1,y;<br>
y =(x&gt;1)?'a':200;<br>
System.out.println(&quot;y=&quot;+y);		<br>
}</p>
<p>结果：<br>
111100<br>
3C<br>
y=200</p>
<p>六、三元运算符：(条件表达式)? 表达式1 : 表达式2<br>
【典型代码】<br>
1.获取两个整数的较大值<br>
2.获取三个数的最大值<br>
【特别说明的】</p>
<ol>
<li>说明<br>
① 条件表达式的结果为boolean类型<br>
② 根据条件表达式真或假，决定执行表达式1，还是表达式2.<br>
如果表达式为true，则执行表达式1。<br>
如果表达式为false，则执行表达式2。<br>
③ 表达式1 和表达式2要求是一致的。<br>
④ 三元运算符可以嵌套使用</li>
<li></li>
</ol>
<p>凡是可以使用三元运算符的地方，都可以改写为if-else<br>
反之，不成立。<br>
3. 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[04 Java基本语法]]></title>
        <id>https://fantaixi.github.io/post/04-java-ji-ben-yu-fa/</id>
        <link href="https://fantaixi.github.io/post/04-java-ji-ben-yu-fa/">
        </link>
        <updated>2020-04-30T06:52:38.000Z</updated>
        <content type="html"><![CDATA[<p>一、Java关键字与标识符</p>
<p>1.1 Java关键字的使用<br>
定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）<br>
特点：关键字中所有字母都为小写<br>
具体有哪些关键字：<br>
<img src="https://fantaixi.github.io/post-images/1588229972083.png" alt="" loading="lazy"><br>
<img src="https://fantaixi.github.io/post-images/1588229980768.png" alt="" loading="lazy"></p>
<p>1.2 保留字<br>
现Java版本尚未使用，但以后版本可能会作为关键字使用。<br>
具体哪些保留字：goto 、const</p>
<p>二、标识符<br>
定义：凡是自己可以起名字的地方都叫标识符。<br>
涉及到的结构：<br>
包名、类名、接口名、变量名、方法名、常量名<br>
规则：(必须要遵守。否则，编译不通过)<br>
<img src="https://fantaixi.github.io/post-images/1588230188167.png" alt="" loading="lazy"></p>
<p>小结：在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</p>
<p>三、变量的使用 ***<br>
3.1 变量的分类<br>
1）按数据类型分类<br>
<img src="https://fantaixi.github.io/post-images/1588231616061.png" alt="" loading="lazy"><br>
详细说明：</p>
<ol>
<li>整型：byte(1字节=8bit) \ short(2字节) \ int(4字节) \ long(8字节)<br>
① byte范围：-128 ~ 127<br>
② 声明long型变量，必须以&quot;l&quot;或&quot;L&quot;结尾<br>
③ 通常，定义整型变量时，使用int型。<br>
④整型的常量，默认类型是：int型</li>
<li>浮点型：float(4字节) \ double(8字节)<br>
① 浮点型，表示带小数点的数值<br>
② float表示数值的范围比long还大<br>
③ 定义float类型变量时，变量要以&quot;f&quot;或&quot;F&quot;结尾<br>
④ 通常，定义浮点型变量时，使用double型。<br>
⑤ 浮点型的常量，默认类型为：double</li>
<li>字符型：char (1字符=2字节)<br>
① 定义char型变量，通常使用一对'',内部只能写一个字符<br>
② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量</li>
<li>布尔型：boolean<br>
① 只能取两个值之一：true 、 false<br>
② 常常在条件判断、循环结构中使用</li>
</ol>
<p>2）按声明的位置分类<br>
<img src="https://fantaixi.github.io/post-images/1588231919694.png" alt="" loading="lazy"></p>
<p>3.2 变量的定义格式<br>
数据类型  变量名 = 变量值;<br>
或<br>
数据类型  变量名;<br>
变量名 = 变量值;</p>
<p>变量使用的注意点：<br>
① 变量必须先声明，后使用<br>
② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了<br>
③ 同一个作用域内，不可以声明两个同名的变量</p>
<p>四、基本数据类型变量间运算规则<br>
4.1 涉及到的基本数据类型：除了boolean之外的其他7种</p>
<p>4.2 自动类型转换(只涉及7种基本数据类型）</p>
<p>小结：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。（自动类型转换）<br>
byte 、char 、short --&gt; int --&gt; long --&gt; float --&gt; double<br>
特别的：当byte、char、short三种类型的变量做运算时，结果为int型（此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量）</p>
<p>4.3 强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。<br>
1.需要使用强转符：( )<br>
2.注意点：强制类型转换，可能导致精度损失。</p>
<p>4.4 String与8种基本数据类型间的运算</p>
<ol>
<li>String属于引用数据类型,翻译为：字符串</li>
<li>声明String类型变量时，使用一对&quot;&quot;</li>
<li>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</li>
<li>运算的结果仍然是String类型<br>
避免：<br>
String s = 123;//编译错误<br>
String s1 = &quot;123&quot;;<br>
int i = (int)s1;//编译错误</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[03 第一个Java程序，Hello World ]]></title>
        <id>https://fantaixi.github.io/post/di-yi-ge-java-cheng-xu-hello-world/</id>
        <link href="https://fantaixi.github.io/post/di-yi-ge-java-cheng-xu-hello-world/">
        </link>
        <updated>2020-04-29T18:09:46.000Z</updated>
        <content type="html"><![CDATA[<p>public class Test {<br>
public static void main(String[] args) {<br>
System.out.println(&quot;Hello World&quot;);<br>
}<br>
}<br>
运行结果如下：<br>
<img src="https://fantaixi.github.io/post-images/1588184119057.png" alt="" loading="lazy"></p>
<p>适当分析：<br>
1）第一个public  类Test的修饰符，作用范围：同一工程下，同类，同包，子类，不同包可见<br>
2）class 声明Test为一个类<br>
3）第二个public 同 1），区别在于是方法的修饰符，对于当前方法对其他类是否可见取决于所在类的修饰符<br>
4）static，表示当前方法为静态方法<br>
5）void，表示当前方法没有返回值<br>
6）String[] args，参数，为String类型的数组，名字args<br>
7）System.out.println，表示在控制台换行输出</p>
<p>小结：一个Java程序必有一个主程序入口，默认的入口如上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[02 Java初识]]></title>
        <id>https://fantaixi.github.io/post/java-chu-shi/</id>
        <link href="https://fantaixi.github.io/post/java-chu-shi/">
        </link>
        <updated>2020-04-29T17:50:08.000Z</updated>
        <content type="html"><![CDATA[<p>1.Java凭什么这么强大？<br>
主要由JVM实现平台无关性，真正实现一处编译，随处运行。</p>
<p>2.JVM、JRE及JDK的区别？<br>
JVM：Java虚拟机<br>
JRE：JVM + Java SE标准类库<br>
JDK：JRE + 开发工具（例如Javac编译工具等）<br>
<img src="https://fantaixi.github.io/post-images/1588182860675.png" alt="" loading="lazy"></p>
<p>3.Java分类<br>
Java SE（标准版）<br>
Java EE（企业版）<br>
Java ME（手机版）</p>
<p>4.一个Java程序的开发流程（粗略）<br>
1）编写源代码  .java<br>
2） javac.exe编译源代码 ，生成字节码文件<br>
3） java.exe运行字节码<br>
<img src="https://fantaixi.github.io/post-images/1588183729386.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[01 Java安装]]></title>
        <id>https://fantaixi.github.io/post/java-an-zhuang/</id>
        <link href="https://fantaixi.github.io/post/java-an-zhuang/">
        </link>
        <updated>2020-04-29T09:15:30.000Z</updated>
        <content type="html"><![CDATA[<p>1.简介<br>
Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。<br>
Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点   。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 。<br>
---&lt;百度百科&gt;<br>
2.安装<br>
2.1 下载jdk<br>
https://www.java.com/zh_CN/download/help/download_options.xml</p>
<p>2.2系统环境变量配置<br>
win7：<br>
<img src="https://fantaixi.github.io/post-images/1588154373181.png" alt="" loading="lazy"><br>
win10：<br>
<img src="https://fantaixi.github.io/post-images/1588154530632.png" alt="" loading="lazy"><br>
2.3 为什么配置path环境变量？<br>
path环境变量：windows操作系统执行命令时所要搜寻的路径<br>
为什么要配置path:希望java的开发工具（javac.exe,java.exe)在任何的文件路径下都可以执行成功。</p>
<p>2.4检查jdk是否安装成功<br>
cmd：java -version<br>
<img src="https://fantaixi.github.io/post-images/1588154715970.png" alt="" loading="lazy"></p>
<p>小结：很大，很持久（通过jvm实现平台无关性）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写在前面]]></title>
        <id>https://fantaixi.github.io/post/xie-zai-qian-mian/</id>
        <link href="https://fantaixi.github.io/post/xie-zai-qian-mian/">
        </link>
        <updated>2020-04-29T08:54:11.000Z</updated>
        <content type="html"><![CDATA[<pre><code>                   编程竞技，菜是原罪
</code></pre>
]]></content>
    </entry>
</feed>