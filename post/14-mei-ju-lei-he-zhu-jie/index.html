<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>14 枚举类和注解 | 饭太稀</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://fantaixi.github.io/favicon.ico?v=1588795446572">
<link rel="stylesheet" href="https://fantaixi.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一、枚举类的使用

枚举类的说明：


1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类
2.当需要定义一组常量时，强烈建议使用枚举类
3.如果枚举类中只一个对象，则可以作为单例模式的实现方式。



如何自定义枚举类？步骤..." />
    <meta name="keywords" content="Java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://fantaixi.github.io">
        <img src="https://fantaixi.github.io/images/avatar.png?v=1588795446572" class="site-logo">
        <h1 class="site-title">饭太稀</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://fantaixi.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">14 枚举类和注解</h2>
            <div class="post-date">2020-05-07</div>
            
            <div class="post-content" v-pre>
              <p>一、枚举类的使用</p>
<ol>
<li>枚举类的说明：</li>
</ol>
<ul>
<li>1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</li>
<li>2.当需要定义一组常量时，强烈建议使用枚举类</li>
<li>3.如果枚举类中只一个对象，则可以作为单例模式的实现方式。</li>
</ul>
<ol start="2">
<li>
<p>如何自定义枚举类？步骤：<br>
//自定义枚举类<br>
class Season{<br>
//1.声明Season对象的属性:private final修饰<br>
private final String seasonName;<br>
private final String seasonDesc;<br>
//2.私化类的构造器,并给对象属性赋值<br>
private Season(String seasonName,String seasonDesc){<br>
this.seasonName = seasonName;<br>
this.seasonDesc = seasonDesc;<br>
}<br>
//3.提供当前枚举类的多个对象：public static final的<br>
public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;);<br>
public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;);<br>
public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;);<br>
public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;);<br>
//4.其他诉求1：获取枚举类对象的属性<br>
public String getSeasonName() {<br>
return seasonName;<br>
}<br>
public String getSeasonDesc() {<br>
return seasonDesc;<br>
}<br>
//4.其他诉求1：提供toString()<br>
@Override<br>
public String toString() {<br>
return &quot;Season{&quot; +<br>
&quot;seasonName='&quot; + seasonName + ''' +<br>
&quot;, seasonDesc='&quot; + seasonDesc + ''' +<br>
'}';<br>
}<br>
}</p>
</li>
<li>
<p>jdk 5.0 新增使用enum定义枚举类。步骤：<br>
//使用enum关键字枚举类<br>
enum Season1 {<br>
//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束<br>
SPRING(&quot;春天&quot;,&quot;春暖花开&quot;),<br>
SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;),<br>
AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;),<br>
WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;);<br>
//2.声明Season对象的属性:private final修饰<br>
private final String seasonName;<br>
private final String seasonDesc;<br>
//2.私有化类的构造器,并给对象属性赋值<br>
private Season1(String seasonName,String seasonDesc){<br>
this.seasonName = seasonName;<br>
this.seasonDesc = seasonDesc;<br>
}</p>
<p>//4.其他诉求1：获取枚举类对象的属性<br>
public String getSeasonName() {<br>
return seasonName;<br>
}<br>
public String getSeasonDesc() {<br>
return seasonDesc;<br>
}<br>
}</p>
</li>
<li>
<p>使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类）<br>
Season1 summer = Season1.SUMMER;<br>
//toString():返回枚举类对象的名称<br>
System.out.println(summer.toString());<br>
//        System.out.println(Season1.class.getSuperclass());<br>
System.out.println(&quot;<strong><strong><strong><strong><strong><strong><strong><strong>&quot;);<br>
//values():返回所有的枚举类对象构成的数组<br>
Season1[] values = Season1.values();<br>
for(int i = 0;i &lt; values.length;i++){<br>
System.out.println(values[i]);<br>
}<br>
System.out.println(&quot;</strong></strong></strong></strong></strong></strong></strong></strong>&quot;);<br>
Thread.State[] values1 = Thread.State.values();<br>
for (int i = 0; i &lt; values1.length; i++) {<br>
System.out.println(values1[i]);<br>
}<br>
//valueOf(String objName):返回枚举类中对象名是objName的对象。<br>
Season1 winter = Season1.valueOf(&quot;WINTER&quot;);<br>
//如果没objName的枚举类对象，则抛异常：IllegalArgumentException<br>
//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);<br>
System.out.println(winter);</p>
</li>
<li>
<p>使用enum定义枚举类之后，如何让枚举类对象分别实现接口：<br>
interface Info{<br>
void show();<br>
}</p>
</li>
</ol>
<p>//使用enum关键字枚举类<br>
enum Season1 implements Info{<br>
//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束<br>
SPRING(&quot;春天&quot;,&quot;春暖花开&quot;){<br>
@Override<br>
public void show() {<br>
System.out.println(&quot;春天在哪里？&quot;);<br>
}<br>
},<br>
SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;){<br>
@Override<br>
public void show() {<br>
System.out.println(&quot;宁夏&quot;);<br>
}<br>
},<br>
AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;){<br>
@Override<br>
public void show() {<br>
System.out.println(&quot;秋天不回来&quot;);<br>
}<br>
},<br>
WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;){<br>
@Override<br>
public void show() {<br>
System.out.println(&quot;大约在冬季&quot;);<br>
}<br>
};<br>
}</p>
<p>二、注解的使用</p>
<ol>
<li>注解的理解<br>
① jdk 5.0 新增的功能<br>
② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。<br>
③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android<br>
中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗<br>
代码和XML配置等。</li>
</ol>
<p>框架 = 注解 + 反射机制 + 设计模式</p>
<ol>
<li>注解的使用示例</li>
</ol>
<ul>
<li>示例一：生成文档相关的注解</li>
<li>示例二：在编译时进行格式检查(JDK内置的个基本注解)<br>
@Override: 限定重写父类方法, 该注解只能用于方法<br>
@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择<br>
@SuppressWarnings: 抑制编译器警告</li>
<li>示例：跟踪代码依赖性，实现替代配置文件功能</li>
</ul>
<ol start="3">
<li>如何自定义注解：参照@SuppressWarnings定义</li>
</ol>
<ul>
<li>① 注解声明为：@interface</li>
<li>② 内部定义成员，通常使用value表示</li>
<li>③ 可以指定成员的默认值，使用default定义</li>
<li>④ 如果自定义注解没成员，表明是一个标识作用。</li>
</ul>
<p>说明：<br>
如果注解有成员，在使用注解时，需要指明成员的值。<br>
自定义注解必须配上注解的信息处理流程(使用反射)才有意义。<br>
自定义注解通过都会指明两个元注解：Retention、Target</p>
<p>代码举例：<br>
@Inherited<br>
@Repeatable(MyAnnotations.class)<br>
@Retention(RetentionPolicy.RUNTIME)<br>
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE})<br>
public @interface MyAnnotation {</p>
<pre><code>String value() default &quot;hello&quot;;
</code></pre>
<p>}<br>
4. 元注解 ：对现有的注解进行解释说明的注解。<br>
jdk 提供的4种元注解：<br>
Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为\RUNTIME<br>
只声明为RUNTIME生命周期的注解，才能通过反射获取。<br>
Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素<br>
<em><strong><strong><strong>出现的频率较低</strong></strong></strong></em><br>
Documented:表示所修饰的注解在被javadoc解析时，保留下来。<br>
Inherited:被它修饰的 Annotation 将具继承性。</p>
<p>---&gt;类比：元数据的概念：String name = &quot;Tom&quot;;<br>
5. 如何获取注解信息:通过发射来进行获取、调用。<br>
前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME.<br>
6.JDK8中注解的新特性：可重复注解、类型注解<br>
6.1 可重复注解：① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class<br>
② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。<br>
6.2 类型注解：<br>
ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明。<br>
ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://fantaixi.github.io/tag/UDPQ9NSLF/" class="tag">
                    Java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://fantaixi.github.io/post/13-java-chang-yong-lei/">
                  <h3 class="post-title">
                    13 Java常用类
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
