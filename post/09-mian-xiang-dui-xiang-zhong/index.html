<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>09 面向对象-中 | 饭太稀</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://fantaixi.github.io/favicon.ico?v=1588795446572">
<link rel="stylesheet" href="https://fantaixi.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一、面向对象的特征二：继承性
1.为什么要有类的继承性？(继承性的好处）

① 减少了代码的冗余，提高了代码的复用性
② 便于功能的扩展
③ 为之后多态性的使用，提供了前提
图示：

2.继承性的格式：
class A extends B{..." />
    <meta name="keywords" content="Java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://fantaixi.github.io">
        <img src="https://fantaixi.github.io/images/avatar.png?v=1588795446572" class="site-logo">
        <h1 class="site-title">饭太稀</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://fantaixi.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">09 面向对象-中</h2>
            <div class="post-date">2020-05-05</div>
            
            <div class="post-content" v-pre>
              <p>一、面向对象的特征二：继承性<br>
1.为什么要有类的继承性？(继承性的好处）</p>
<ul>
<li>① 减少了代码的冗余，提高了代码的复用性</li>
<li>② 便于功能的扩展</li>
<li>③ 为之后多态性的使用，提供了前提<br>
图示：<br>
<img src="https://fantaixi.github.io/post-images/1588757719288.png" alt="" loading="lazy"><br>
2.继承性的格式：<br>
class A extends B{}</li>
<li>A:子类、派生类、subclass</li>
<li>B:父类、超类、基类、superclass</li>
</ul>
<p>3.子类继承父类以后有哪些不同？<br>
3.1体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。</p>
<ul>
<li>特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。<br>
3.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。</li>
<li>子类和父类的关系，不同于子集和集合的关系。</li>
<li>extends：延展、扩展</li>
</ul>
<p>4.Java中继承性的说明<br>
1.一个类可以被多个子类继承。<br>
2.Java中类的单继承性：一个类只能有一个父类<br>
3.子父类是相对的概念。<br>
4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类<br>
5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p>
<p>图示：<br>
<img src="https://fantaixi.github.io/post-images/1588757866009.png" alt="" loading="lazy"></p>
<p>5.java.lang.Object类的理解</p>
<ol>
<li>如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li>
<li>所有的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类</li>
<li>意味着，所的java类具有java.lang.Object类声明的功能。</li>
</ol>
<p>Object类的使用：<br>
1.java.lang.Object类的说明：</p>
<ul>
<li>1.Object类是所Java类的根父类</li>
<li>2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</li>
<li>3.Object类中的功能(属性、方法)就具通用性。</li>
<li>属性：无</li>
<li>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()/ wait() / notify()/notifyAll()</li>
<li>
<ol start="4">
<li>Object类只声明了一个空参的构造器<br>
2.equals()方法<br>
2.1 equals()的使用：</li>
<li>是一个方法，而非运算符</li>
</ol>
</li>
<li>
<ol start="2">
<li>只能适用于引用数据类型</li>
</ol>
</li>
<li>
<ol start="3">
<li>Object类中equals()的定义：</li>
</ol>
</li>
<li>public boolean equals(Object obj) {<br>
return (this == obj);<br>
}</li>
<li>说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
<li></li>
<li>
<ol start="4">
<li>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的&quot;实体内容&quot;是否相同。</li>
</ol>
</li>
<li></li>
<li>
<ol start="5">
<li>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的&quot;实体内容&quot;是否相同。那么，就需要对Object类中的equals()进行重写.</li>
</ol>
</li>
<li>重写的原则：比较两个对象的实体内容是否相同.<br>
2.2 如何重写equals()<br>
2.2.1 手动重写举例：<br>
class User{<br>
String name;<br>
int age;<br>
//重写其equals()方法<br>
public boolean equals(Object obj){<br>
if(obj == this){<br>
return true;<br>
}<br>
if(obj instanceof User){<br>
User u = (User)obj;<br>
return this.age == u.age &amp;&amp; this.name.equals(u.name);<br>
}<br>
return false;<br>
}<br>
}<br>
2.2.2 开发中如何实现：自动生成的<br>
2.3 回顾 == 运算符的使用：</li>
<li>== ：运算符</li>
<li>
<ol>
<li>可以使用在基本数据类型变量和引用数据类型变量中</li>
</ol>
</li>
<li>
<ol start="2">
<li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</li>
</ol>
</li>
<li>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
<li>补充： == 符号使用时，必须保证符号左右两边的变量类型一致。</li>
</ul>
<ol>
<li>toString()方法<br>
3.1 toString()的使用：
<ol>
<li>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</li>
</ol>
</li>
</ol>
<ul>
<li></li>
<li>
<ol start="2">
<li>Object类中toString()的定义：</li>
</ol>
</li>
<li>public String toString() {<br>
return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());<br>
}</li>
<li></li>
<li>
<ol start="3">
<li>像String、Date、File、包装类等都重写了Object类中的toString()方法。</li>
</ol>
</li>
<li>使得在调用对象的toString()时，返回&quot;实体内容&quot;信息</li>
<li></li>
<li>
<ol start="4">
<li>自定义类也可以重写toString()方法，当调用此方法时，返回对象的&quot;实体内容&quot;<br>
3.2 如何重写toString()<br>
举例：<br>
//自动实现<br>
@Override<br>
public String toString() {<br>
return &quot;Customer [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;<br>
}</li>
</ol>
</li>
</ul>
<p>二、方法的重写<br>
1.什么是方法的重写(override 或 overwrite)？<br>
子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p>
<ol start="2">
<li>应用：<br>
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。<br>
3.举例：<br>
class Circle{<br>
public double findArea(){}//求面积<br>
}<br>
class Cylinder extends Circle{<br>
public double findArea(){}//求表面积<br>
}</li>
</ol>
<hr>
<p>class Account{<br>
public boolean withdraw(double amt){}<br>
}<br>
class CheckAccount extends Account{<br>
public boolean withdraw(double amt){}<br>
}</p>
<p>4.重写的规则：<br>
方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{</p>
<ul>
<li>
<pre><code> 				//方法体
</code></pre>
</li>
<li>
<pre><code> 			}
</code></pre>
</li>
<li>
<pre><code> 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
</code></pre>
</li>
<li>
<pre><code> ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
</code></pre>
</li>
<li>
<pre><code> ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
</code></pre>
</li>
<li>
<pre><code> 	&gt;特殊情况：子类不能重写父类中声明为private权限的方法
</code></pre>
</li>
<li>
<pre><code> ③ 返回值类型：
</code></pre>
</li>
<li>
<pre><code> 	&gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
</code></pre>
</li>
<li>
<pre><code> 	&gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
</code></pre>
</li>
<li>
<pre><code> 	&gt;父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
</code></pre>
</li>
<li>
<pre><code> ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。</li>
</ul>
<p>5.面试题：<br>
区分方法的重写和重载？<br>
答：<br>
① 二者的概念：<br>
② 重载和重写的具体规则<br>
③ 重载：不表现为多态性。<br>
重写：表现为多态性。<br>
重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。<br>
所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；<br>
而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</p>
<p>《Java编程思想》：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p>
<p>三、super关键字<br>
1.super 关键字可以理解为：父类的</p>
<p>2.可以用来调用的结构：<br>
属性、方法、构造器</p>
<p>3.super调用属性、方法：<br>
3.1 我们可以在子类的方法或构造器中。通过使用&quot;super.属性&quot;或&quot;super.方法&quot;的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略&quot;super.&quot;<br>
3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用&quot;super.属性&quot;的方式，表明调用的是父类中声明的属性。<br>
3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用&quot;super.方法&quot;的方式，表明调用的是父类中被重写的方法。</p>
<p>4.super调用构造器：<br>
4.1  我们可以在子类的构造器中显式的使用&quot;super(形参列表)&quot;的方式，调用父类中声明的指定的构造器<br>
4.2 &quot;super(形参列表)&quot;的使用，必须声明在子类构造器的首行！<br>
4.3 我们在类的构造器中，针对于&quot;this(形参列表)&quot;或&quot;super(形参列表)&quot;只能二一，不能同时出现<br>
4.4 在构造器的首行，没显式的声明&quot;this(形参列表)&quot;或&quot;super(形参列表)&quot;，则默认调用的是父类中空参的构造器：super()<br>
4.5 在类的多个构造器中，至少一个类的构造器中使用了&quot;super(形参列表)&quot;，调用父类中的构造器</p>
<p>四、子类对象实例化全过程<br>
1.从结果上看：继承性</p>
<blockquote>
<p>子类继承父类以后，就获取了父类中声明的属性或方法。<br>
创建子类的对象，在堆空间中，就会加载所父类中声明的属性。<br>
2.从过程上看：<br>
当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。<br>
3.强调说明：<br>
虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p>
</blockquote>
<p>五、面向对象的特征三：多态性<br>
1.多态性的理解：可以理解为一个事物的多种形态。<br>
2.何为多态性：<br>
对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）<br>
举例：<br>
Person p = new Man();<br>
Object obj = new Date();<br>
3.多态性的使用：虚拟方法调用</p>
<blockquote>
<p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。<br>
总结：编译，看左边；运行，看右边。<br>
4.多态性的使用前提：<br>
① 类的继承关系  ② 方法的重写<br>
5.多态性的应用举例：<br>
举例一：<br>
public void func(Animal animal){//Animal animal = new Dog();<br>
animal.eat();<br>
animal.shout();<br>
}<br>
举例二：<br>
public void method(Object obj){	<br>
}<br>
举例三：<br>
class Driver{<br>
public void doData(Connection conn){//conn = new MySQlConnection(); / conn = new OracleConnection();<br>
//规范的步骤去操作数据<br>
//		conn.method1();<br>
//		conn.method2();<br>
//		conn.method3();		<br>
}<br>
}</p>
</blockquote>
<p>6.多态性使用的注意点：<br>
对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
<hr>
<p>7.关于向上转型与向下转型：<br>
7.1 向上转型：多态<br>
7.2 向下转型：<br>
7.2.1 为什么使用向下转型：<br>
有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。<br>
7.2.2 如何实现向下转型：<br>
使用强制类型转换符：()<br>
7.2.3 使用时的注意点：<br>
① 使用强转时，可能出现ClassCastException的异常。（两个类型转换不兼容）<br>
② 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。<br>
7.2.4 instanceof的使用：<br>
① a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。<br>
② 如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。<br>
③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。<br>
7.2.5 图示：<br>
<img src="https://fantaixi.github.io/post-images/1588759288912.png" alt="" loading="lazy"><br>
8. 面试题：<br>
8.1 谈谈你对多态性的理解？<br>
① 实现代码的通用性。<br>
② Object类中定义的public boolean equals(Object obj){  }<br>
JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)<br>
③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）<br>
8.2 多态是编译时行为还是运行时行为？  运行时行为</p>
<p>六、单元测试方法<br>
Java中的JUnit单元测试<br>
步骤：<br>
1.中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步<br>
2.创建Java类，进行单元测试。<br>
此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器<br>
3.此类中声明单元测试方法。<br>
此时的单元测试方法：方法的权限是public,没返回值，没形参</p>
<p>4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p>
<p>5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。<br>
6.写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p>
<p>说明：<br>
1.如果执行结果没任何异常：绿条<br>
2.如果执行结果出现异常：红条</p>
<p>七、包装类的使用<br>
1.为什么要有包装类(或封装类）<br>
为了使基本数据类型的变量具有类的特征，引入包装类。</p>
<p>2.基本数据类型与对应的包装类：<br>
<img src="https://fantaixi.github.io/post-images/1588759915421.png" alt="" loading="lazy"></p>
<p>3.需要掌握的类型间的转换：（基本数据类型、包装类、String）<br>
<img src="https://fantaixi.github.io/post-images/1588759921171.png" alt="" loading="lazy"></p>
<p>简易版：<br>
基本数据类型&lt;---&gt;包装类：JDK 5.0 新特性：自动装箱 与自动拆箱<br>
基本数据类型、包装类---&gt;String:调用String重载的valueOf(Xxx xxx)<br>
String---&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)<br>
注意：转换时，可能会报NumberFormatException<br>
应用场景举例：<br>
① Vector类中关于添加元素，只定义了形参为Object类型的方法：<br>
v.addElement(Object obj);   //基本数据类型 ---&gt;包装类 ---&gt;使用多态</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://fantaixi.github.io/tag/UDPQ9NSLF/" class="tag">
                    Java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://fantaixi.github.io/post/08-mian-xiang-dui-xiang-shang/">
                  <h3 class="post-title">
                    08 面向对象-上
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
