<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>15 Java集合 | 饭太稀</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://fantaixi.github.io/favicon.ico?v=1588795446572">
<link rel="stylesheet" href="https://fantaixi.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一、数组与集合


集合与数组存储数据概述：
集合、数组都是对多个数据进行存储操作的结构，简称Java容器。
说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中)


数组存储的特点：
..." />
    <meta name="keywords" content="Java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://fantaixi.github.io">
        <img src="https://fantaixi.github.io/images/avatar.png?v=1588795446572" class="site-logo">
        <h1 class="site-title">饭太稀</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://fantaixi.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">15 Java集合</h2>
            <div class="post-date">2020-05-07</div>
            
            <div class="post-content" v-pre>
              <p>一、数组与集合</p>
<ol>
<li>
<p>集合与数组存储数据概述：<br>
集合、数组都是对多个数据进行存储操作的结构，简称Java容器。<br>
说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中)</p>
</li>
<li>
<p>数组存储的特点：</p>
</li>
</ol>
<blockquote>
<p>一旦初始化以后，其长度就确定了。<br>
数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。</p>
</blockquote>
<ul>
<li>
<pre><code> 比如：String[] arr;int[] arr1;Object[] arr2;
</code></pre>
</li>
</ul>
<ol start="3">
<li>数组存储的弊端：</li>
</ol>
<ul>
<li>
<pre><code> &gt; 一旦初始化以后，其长度就不可修改。
</code></pre>
</li>
<li>
<pre><code> &gt; 数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。
</code></pre>
</li>
<li>
<pre><code> &gt; 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用
</code></pre>
</li>
<li>
<pre><code> &gt; 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。
</code></pre>
</li>
</ul>
<ol start="4">
<li>集合存储的优点：<br>
解决数组存储数据方面的弊端。</li>
</ol>
<p>二、Collection接口<br>
1.单列集合框架结构<br>
|----Collection接口：单列集合，用来存储一个一个的对象</p>
<ul>
<li>
<pre><code>     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组
</code></pre>
</li>
<li>
<pre><code>         |----ArrayList、LinkedList、Vector
</code></pre>
</li>
<li></li>
<li>
<pre><code>     |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”
</code></pre>
</li>
<li>
<pre><code>         |----HashSet、LinkedHashSet、TreeSet
</code></pre>
</li>
</ul>
<p>对应图示：<br>
<img src="https://fantaixi.github.io/post-images/1588788224614.png" alt="" loading="lazy"></p>
<p>2.Collection接口常用方法：<br>
add(Object obj),addAll(Collection coll),size(),isEmpty(),clear();<br>
contains(Object obj),containsAll(Collection coll),remove(Object obj),removeAll(Collection coll),retainsAll(Collection coll),equals(Object obj);<br>
hasCode(),toArray(),iterator();</p>
<p>3.Collection集合与数组间的转换<br>
//集合 ---&gt;数组：toArray()<br>
Object[] arr = coll.toArray();<br>
for(int i = 0;i &lt; arr.length;i++){<br>
System.out.println(arr[i]);<br>
}</p>
<p>//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)<br>
List<String> list = Arrays.asList(new String[]{&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;});<br>
System.out.println(list);</p>
<p>List arr1 = Arrays.asList(new int[]{123, 456});<br>
System.out.println(arr1.size());//1</p>
<p>List arr2 = Arrays.asList(new Integer[]{123, 456});<br>
System.out.println(arr2.size());//2</p>
<p>4.使用Collection集合存储对象，要求对象所属的类满足：<br>
向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</p>
<p>三、Iterator接口与foreach循环<br>
1.遍历Collection的两种方式：<br>
① 使用迭代器Iterator  ② foreach循环（或增强for循环）<br>
2.java.utils包下定义的迭代器接口：Iterator<br>
2.1说明：<br>
Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。<br>
GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。<br>
2.2作用：遍历集合Collectiton元素<br>
2.3如何获取实例：coll.iterator()返回一个迭代器实例<br>
2.4遍历的代码实现：<br>
Iterator iterator = coll.iterator();<br>
//hasNext():判断是否还下一个元素<br>
while(iterator.hasNext()){<br>
//next():①指针下移 ②将下移以后集合位置上的元素返回<br>
System.out.println(iterator.next());<br>
}<br>
2.5图示说明：<br>
<img src="https://fantaixi.github.io/post-images/1588788373686.png" alt="" loading="lazy"></p>
<p>2.6 remove()的使用：<br>
//测试Iterator中的remove()<br>
//如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。<br>
//内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()<br>
@Test<br>
public void test3(){<br>
Collection coll = new ArrayList();<br>
coll.add(123);<br>
coll.add(456);<br>
coll.add(new Person(&quot;Jerry&quot;,20));<br>
coll.add(new String(&quot;Tom&quot;));<br>
coll.add(false);<br>
//删除集合中&quot;Tom&quot;<br>
Iterator iterator = coll.iterator();<br>
while (iterator.hasNext()){<br>
//            iterator.remove();<br>
Object obj = iterator.next();<br>
if(&quot;Tom&quot;.equals(obj)){<br>
iterator.remove();<br>
//                iterator.remove();<br>
}<br>
}<br>
//遍历集合<br>
iterator = coll.iterator();<br>
while (iterator.hasNext()){<br>
System.out.println(iterator.next());<br>
}<br>
}</p>
<p>3.jdk5.0新特性--增强for循环：(foreach循环)</p>
<p>1.遍历集合举例：<br>
@Test<br>
public void test1(){<br>
Collection coll = new ArrayList();<br>
coll.add(123);<br>
coll.add(456);<br>
coll.add(new Person(&quot;Jerry&quot;,20));<br>
coll.add(new String(&quot;Tom&quot;));<br>
coll.add(false);<br>
//for(集合元素的类型 局部变量 : 集合对象)<br>
for(Object obj : coll){<br>
System.out.println(obj);<br>
}<br>
}<br>
说明：<br>
内部仍然调用了迭代器。</p>
<p>2.遍历数组举例：</p>
<p>@Test<br>
public void test2(){<br>
int[] arr = new int[]{1,2,3,4,5,6};<br>
//for(数组元素的类型 局部变量 : 数组对象)<br>
for(int i : arr){<br>
System.out.println(i);<br>
}<br>
}</p>
<p>四、Collection子接口：List接口</p>
<ol>
<li>
<p>存储的数据特点：存储有序的、可重复的数据。</p>
</li>
<li>
<p>常用方法：(记住)<br>
增：add(Object obj)<br>
删：remove(int index) / remove(Object obj)<br>
改：set(int index, Object ele)<br>
查：get(int index)<br>
插：add(int index, Object ele)<br>
长度：size()<br>
遍历：① Iterator迭代器方式<br>
② 增强for循环<br>
③ 普通的循环</p>
</li>
<li>
<p>常用实现类：<br>
|----Collection接口：单列集合，用来存储一个一个的对象</p>
</li>
</ol>
<ul>
<li>|----List接口：存储序的、可重复的数据。  --&gt;“动态”数组,替换原的数组</li>
<li>
<pre><code> |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储
</code></pre>
</li>
<li>
<pre><code> |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储
</code></pre>
</li>
<li>
<pre><code> |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储
</code></pre>
</li>
</ul>
<ol start="4">
<li>源码分析(难点)<br>
4.1 ArrayList的源码分析：</li>
</ol>
<ul>
<li>
<p>2.1 jdk 7情况下</p>
</li>
<li>
<pre><code> ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData
</code></pre>
</li>
<li>
<pre><code> list.add(123);//elementData[0] = new Integer(123);
</code></pre>
</li>
<li>
<pre><code> ...
</code></pre>
</li>
<li>
<pre><code> list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。
</code></pre>
</li>
<li>
<pre><code> 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。
</code></pre>
</li>
<li></li>
<li>
<pre><code> 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)
</code></pre>
</li>
<li></li>
<li>
<p>2.2 jdk 8中ArrayList的变化：</p>
</li>
<li>
<pre><code> ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没创建长度为10的数组
</code></pre>
</li>
<li>
<pre><code> list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]
</code></pre>
</li>
<li>
<pre><code> ...
</code></pre>
</li>
<li>
<pre><code> 后续的添加和扩容操作与jdk 7 无异。
</code></pre>
</li>
<li>
<p>2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象</p>
</li>
<li>
<pre><code> 的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。
</code></pre>
</li>
</ul>
<p>4.2 LinkedList的源码分析：</p>
<ul>
<li>
<pre><code> LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null
</code></pre>
</li>
<li>
<pre><code> list.add(123);//将123封装到Node中，创建了Node对象。
</code></pre>
</li>
<li>
<pre><code> 其中，Node定义为：体现了LinkedList的双向链表的说法
</code></pre>
</li>
<li>
<pre><code> private static class Node&lt;E&gt; {
      E item;
      Node&lt;E&gt; next;
      Node&lt;E&gt; prev;
      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
      this.item = element;
      this.next = next;
      this.prev = prev;
      }
  }
</code></pre>
</li>
</ul>
<p>4.3 Vector的源码分析：<br>
jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。<br>
在扩容方面，默认扩容为原来的数组长度的2倍。</p>
<ol start="5">
<li>存储的元素的要求：<br>
添加的对象，所在的类要重写equals()方法<br>
[面试题]</li>
</ol>
<ul>
<li>面试题：ArrayList、LinkedList、Vector者的异同？</li>
<li>同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</li>
<li>不同：见上（第3部分+第4部分）</li>
</ul>
<p>五、Collection子接口：Set接口</p>
<ol>
<li>
<p>存储的数据特点：无序的、不可重复的元素<br>
具体的：<br>
以HashSet为例说明：</p>
</li>
<li>
<p>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</p>
</li>
<li>
<p>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</p>
</li>
<li>
<p>元素添加过程：(以HashSet为例)<br>
我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br>
此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置，判断<br>
数组此位置上是否已经元素：<br>
如果此位置上没其他元素，则元素a添加成功。 ---&gt;情况1<br>
如果此位置上其他元素b(或以链表形式存在的多个元素，则比较元素a与元素b的hash值：<br>
如果hash值不相同，则元素a添加成功。---&gt;情况2<br>
如果hash值相同，进而需要调用元素a所在类的equals()方法：<br>
equals()返回true,元素a添加失败<br>
equals()返回false,则元素a添加成功。---&gt;情况2</p>
</li>
</ol>
<p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。<br>
jdk 7 :元素a放到数组中，指向原来的元素。<br>
jdk 8 :原来的元素在数组中，指向元素a<br>
总结：七上八下</p>
<p>HashSet底层：数组+链表的结构。（前提：jdk7)</p>
<ol start="3">
<li>
<p>常用方法<br>
Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法。</p>
</li>
<li>
<p>常用实现类：<br>
|----Collection接口：单列集合，用来存储一个一个的对象</p>
</li>
</ol>
<ul>
<li>
<pre><code>     |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”
</code></pre>
</li>
<li>
<pre><code>         |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值
</code></pre>
</li>
<li>
<pre><code>             |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历
</code></pre>
</li>
<li>
<pre><code>            在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。                   对于频繁的遍历操作，LinkedHashSet效率高于HashSet.
</code></pre>
</li>
<li>
<pre><code>         |----TreeSet：可以照添加对象的指定属性，进行排序。
</code></pre>
</li>
</ul>
<ol start="5">
<li>存储对象所在类的要求：<br>
HashSet/LinkedHashSet:</li>
</ol>
<p>要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()<br>
要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</p>
<ul>
<li>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li>
</ul>
<p>TreeSet:<br>
1.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().<br>
2.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</p>
<ol start="6">
<li>TreeSet的使用<br>
6.1 使用说明:<br>
1.向TreeSet中添加的数据，要求是相同类的对象。<br>
2.两种排序方式：自然排序（实现Comparable接口 和 定制排序（Comparator）</li>
</ol>
<p>6.2 常用的排序方式:<br>
//方式一：自然排序<br>
@Test<br>
public void test1(){<br>
TreeSet set = new TreeSet();<br>
//失败：不能添加不同类的对象<br>
//        set.add(123);<br>
//        set.add(456);<br>
//        set.add(&quot;AA&quot;);<br>
//        set.add(new User(&quot;Tom&quot;,12));<br>
//举例一：<br>
//        set.add(34);<br>
//        set.add(-34);<br>
//        set.add(43);<br>
//        set.add(11);<br>
//        set.add(8);<br>
//举例二：<br>
set.add(new User(&quot;Tom&quot;,12));<br>
set.add(new User(&quot;Jerry&quot;,32));<br>
set.add(new User(&quot;Jim&quot;,2));<br>
set.add(new User(&quot;Mike&quot;,65));<br>
set.add(new User(&quot;Jack&quot;,33));<br>
set.add(new User(&quot;Jack&quot;,56));</p>
<pre><code>    Iterator iterator = set.iterator();
    while(iterator.hasNext()){
        System.out.println(iterator.next());
    }
}
</code></pre>
<p>//方式二：定制排序<br>
@Test<br>
public void test2(){<br>
Comparator com = new Comparator() {<br>
//照年龄从小到大排列<br>
@Override<br>
public int compare(Object o1, Object o2) {<br>
if(o1 instanceof User &amp;&amp; o2 instanceof User){<br>
User u1 = (User)o1;<br>
User u2 = (User)o2;<br>
return Integer.compare(u1.getAge(),u2.getAge());<br>
}else{<br>
throw new RuntimeException(&quot;输入的数据类型不匹配&quot;);<br>
}<br>
}<br>
};<br>
TreeSet set = new TreeSet(com);<br>
set.add(new User(&quot;Tom&quot;,12));<br>
set.add(new User(&quot;Jerry&quot;,32));<br>
set.add(new User(&quot;Jim&quot;,2));<br>
set.add(new User(&quot;Mike&quot;,65));<br>
set.add(new User(&quot;Mary&quot;,33));<br>
set.add(new User(&quot;Jack&quot;,33));<br>
set.add(new User(&quot;Jack&quot;,56));<br>
Iterator iterator = set.iterator();<br>
while(iterator.hasNext()){<br>
System.out.println(iterator.next());<br>
}<br>
}</p>
<p>六、Map接口<br>
双列集合框架：Map<br>
1.常用实现类结构<br>
|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</p>
<ul>
<li>
<pre><code>  |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value
</code></pre>
</li>
<li>
<pre><code>         |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。
</code></pre>
</li>
<li>
<pre><code>               原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。
</code></pre>
</li>
<li>
<pre><code>               对于频繁的遍历操作，此类执行效率高于HashMap。
</code></pre>
</li>
<li>
<pre><code>  |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序
</code></pre>
</li>
<li>
<pre><code>                 底层使用红黑树
</code></pre>
</li>
<li>
<pre><code>  |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value
</code></pre>
</li>
<li>
<pre><code>         |----Properties:常用来处理配置文件。key和value都是String类型
</code></pre>
</li>
<li></li>
<li></li>
<li>
<pre><code> HashMap的底层：数组+链表  （jdk7及之前)
</code></pre>
</li>
<li>
<pre><code>               数组+链表+红黑树 （jdk 8)
</code></pre>
</li>
</ul>
<p>2.存储结构的理解：</p>
<blockquote>
<p>Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)<br>
Map中的value:无序的、可重复的，使用Collection存储所的value ---&gt;value所在的类要重写equals()<br>
一个键值对：key-value构成了一个Entry对象。<br>
Map中的entry:无序的、不可重复的，使用Set存储所的entry</p>
</blockquote>
<p>图示：<br>
<img src="https://fantaixi.github.io/post-images/1588788678652.png" alt="" loading="lazy"></p>
<p>3.常用方法</p>
<ul>
<li>添加：put(Object key,Object value)</li>
<li>删除：remove(Object key)</li>
<li>修改：put(Object key,Object value)</li>
<li>查询：get(Object key)</li>
<li>长度：size()</li>
<li>遍历：keySet() / values() / entrySet()</li>
</ul>
<ol>
<li>内存结构说明：（难点）<br>
4.1 HashMap在jdk7中实现原理：<br>
HashMap map = new HashMap():</li>
</ol>
<ul>
<li>
<pre><code> 在实例化以后，底层创建了长度是16的一维数组Entry[] table。
</code></pre>
</li>
<li>
<pre><code> ...可能已经执行过多次put...
</code></pre>
</li>
<li>
<pre><code> map.put(key1,value1):
</code></pre>
</li>
<li>
<pre><code> 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
</code></pre>
</li>
<li>
<pre><code> 如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
</code></pre>
</li>
<li>
<pre><code> 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：
</code></pre>
</li>
<li>
<pre><code>         如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
</code></pre>
</li>
<li>
<pre><code>         如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
</code></pre>
</li>
<li>
<pre><code>                 如果equals()返回false:此时key1-value1添加成功。----情况3
</code></pre>
</li>
<li>
<pre><code>                 如果equals()返回true:使用value1替换value2。
</code></pre>
</li>
<li></li>
<li>
<pre><code> 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。
</code></pre>
</li>
<li></li>
<li>
<pre><code>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。
</code></pre>
</li>
</ul>
<p>4.2 HashMap在jdk8中相较于jdk7在底层实现方面的不同：</p>
<ol>
<li>new HashMap():底层没创建一个长度为16的数组</li>
<li>jdk 8底层的数组是：Node[],而非Entry[]</li>
<li>首次调用put()方法时，底层创建长度为16的数组</li>
<li>jdk7底层结构只：数组+链表。jdk8中底层结构：数组+链表+红黑树。<br>
4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）<br>
4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li>
</ol>
<p>4.3 HashMap底层典型属性的属性的说明：<br>
DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16<br>
DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75<br>
threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12<br>
TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8<br>
MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</p>
<p>4.4 LinkedHashMap的底层实现原理(了解)<br>
LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap.<br>
区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node.<br>
<img src="https://fantaixi.github.io/post-images/1588788723692.png" alt="" loading="lazy"></p>
<ol start="5">
<li>TreeMap的使用<br>
//向TreeMap中添加key-value，要求key必须是由同一个类创建的对象<br>
//因为要照key进行排序：自然排序 、定制排序</li>
</ol>
<p>6.使用Properties读取配置文件<br>
//Properties:常用来处理配置文件。key和value都是String类型<br>
public static void main(String[] args)  {<br>
FileInputStream fis = null;<br>
try {<br>
Properties pros = new Properties();<br>
fis = new FileInputStream(&quot;jdbc.properties&quot;);<br>
pros.load(fis);//加载流对应的文件<br>
String name = pros.getProperty(&quot;name&quot;);<br>
String password = pros.getProperty(&quot;password&quot;);<br>
System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password);<br>
} catch (IOException e) {<br>
e.printStackTrace();<br>
} finally {<br>
if(fis != null){<br>
try {<br>
fis.close();<br>
} catch (IOException e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
}</p>
<p>七、Collections工具类的使用<br>
Collections工具类<br>
1.作用：操作Collection和Map的工具类</p>
<p>2.常用方法：<br>
reverse(List)：反转 List 中元素的顺序<br>
shuffle(List)：对 List 集合元素进行随机排序<br>
sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序<br>
sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br>
swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换<br>
Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>
Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素<br>
Object min(Collection)<br>
Object min(Collection，Comparator)<br>
int frequency(Collection，Object)：返回指定集合中指定元素的出现次数<br>
void copy(List dest,List src)：将src中的内容复制到dest中<br>
boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值<br>
<img src="https://fantaixi.github.io/post-images/1588788821537.png" alt="" loading="lazy"></p>
<p>说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。<br>
使用synchronizedList(List list） 和 synchronizedMap(Map map）</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://fantaixi.github.io/tag/UDPQ9NSLF/" class="tag">
                    Java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://fantaixi.github.io/post/14-mei-ju-lei-he-zhu-jie/">
                  <h3 class="post-title">
                    14 枚举类和注解
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
